<html>

<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.js"></script>
<script src="libs/keyboard.js"></script>
<script src="libs/physi.js"></script>
</head>

<body>

<script type="text/javascript">
'use strict';

Physijs.scripts.worker = 'physijs_worker.js';
Physijs.scripts.ammo = 'libs/ammo.js';

var renderer;
var scene;
var camera;
var light;
var ball;
var spawnChair;
var paddle1, paddle2;	
var chair_material;
var score = {
	score1: 0,
	score2: 0,
	firstPerson: false
};
var victory = false;




function createPlayBottom()
{
	var planeMaterial = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({color: 0x18ffff}),
			.0, // low friction
			.3 // high restitution
			);
	var plane = new Physijs.BoxMesh( 
			new THREE.BoxGeometry( 100, 1, 200 ),
			planeMaterial,
			0 // mass
			);
	scene.add(plane);
}

function createBoundingWalls()
{

	var wallMaterial = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({color: 0x18ffff}),
			.0, // low friction
			1.0  // high restitution
		);

	var leftWall = new THREE.BoxGeometry( 5, 20, 200 );
	var wall1 = new Physijs.BoxMesh( leftWall, wallMaterial, 0  );
	wall1.position.x = -50;
	wall1.position.y = 1;
	scene.add( wall1 );

	var wallMaterial2 = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({color: 0x18ffff}),
			.0, // low friction
			1.0  // high restitution
		);


	var rightWall = new THREE.BoxGeometry( 5, 20, 200 );
	var wall2 = new Physijs.BoxMesh( leftWall, wallMaterial2, 0 );
	wall2.position.x = 50;
	wall2.position.y = 1;
	scene.add( wall2 );

}

function createPaddles()
{
	var opponentPaddle = new THREE.BoxGeometry( 30, 20, 5 );

	var paddleMat1 = Physijs.createMaterial(
		new THREE.MeshPhongMaterial({color: 0xFF1744}),
		0,
		1.5	
	);

	paddle1 = new Physijs.BoxMesh( opponentPaddle, paddleMat1, 0 );
	paddle1.position.z = -90
	paddle1.position.y = 10
	scene.add( paddle1 );

	var edges1 = new THREE.EdgesHelper( paddle1, 0x000000 );
	//scene.add( edges1 );

	var playerPaddle = new THREE.BoxGeometry( 30, 20, 5 );

	var paddleMat2 = Physijs.createMaterial(
		new THREE.MeshPhongMaterial({color: 0xFFea00}),
		0,
		1.5
	);

	paddle2 = new Physijs.BoxMesh( playerPaddle, paddleMat2, 0);
	paddle2.position.set(10, 10, 90);
	scene.add( paddle2 );

	var edges2 = new THREE.EdgesHelper( paddle2, 0x000000 );
	//scene.add( edges2 );
}

function createBall()
{
	var ballSphere = new THREE.SphereGeometry( 6, 32, 32 );
	var normalMaterial = new THREE.MeshNormalMaterial();
	var material = Physijs.createMaterial(
		normalMaterial,
	        .1, // friction
	    	2 // restitution bouncyness	
	    );
	ball = new Physijs.SphereMesh( ballSphere, material, 0.5  );
	ball.position.set(-15, 60, 83)

	scene.add( ball );
}

/// Game logic
var xDir = .08;
var yDir = .08;
var firstUpdate = true;
function moveBallAndMaintainPaddles()
{
	if (score.firstPerson) {
		camera.position.x = paddle2.position.x
		camera.position.y = paddle2.position.y + 0
		camera.position.z = paddle2.position.z + 1
		if (firstUpdate) {
			camera.lookAt(new THREE.Vector3( 1, 0, 0 ))
			firstUpdate = false;
		}
	} else {
		camera.position.set( 0, 200, 150);
		camera.lookAt(scene.position);
		firstUpdate = true;
	}



	if( Key.isDown( Key.A ) && paddle2.position.x > -30 )
	{
		paddle2.position.x -= 4;
	}
	else if( Key.isDown( Key.D ) && paddle2.position.x < 30 )
	{
		paddle2.position.x += 4;
	}

	
	if (ball.position.y < -100) {
		var fac = new THREE.Vector3( 0, 0, 0 )
		ball.setAngularVelocity(fac);
		ball.setLinearVelocity(fac);

		// increment ai score
		score.score1++;

		ball.position.set(-15, 60, 83)
		ball.__dirtyPosition = true;

		paddle1.position.x = ball.position.x - 30;
	}
	else if (ball.position.y > 100) {
		var fac = new THREE.Vector3( 0, 0, 0 )
		ball.setAngularVelocity(fac);
		ball.setLinearVelocity(fac);

		// increment player score
		score.score2++;

		ball.position.set(15, 60, -83)
		
		ball.__dirtyPosition = true;
	}
	else {
		// AI LOL
		paddle1.position.x = ball.position.x;
	}

	if ((score.score1 === 4 || score.score2 === 4) && !victory) {
		spawnChair();
		victory = true;
	}


	/*

	// check bounds left and right
	if( ball.position.x < -4.4 )
	{
		xDir = .08;
		three.play();
	}
	else if( ball.position.x > 4.4 )
	{
		xDir = -0.08;
		four.play();
	}

	if( ball.position.y < -8.5 && yDir < 0 )
	{
		yDir = 0.08;

		if( Math.abs( paddle2.position.x - ball.position.x ) <= 2 )
		{
			xDir = -xDir;
			one.play();
		}
		else
		{
			ball.position.x = ball.position.y = 0;
			explode.play();
			score.score1++;
		}
	}
	else if( ball.position.y > 8.5 && yDir > 0 )
	{
		yDir = -0.08;

		if( Math.abs( paddle1.position.x - ball.position.x ) <= 2 )
		{
			xDir = -xDir;
			two.play();
		}
		else
		{
			ball.position.x = ball.position.y = 0;
			explode.play();
			score.score2++;
		}
	}
	*/

}

var explode, one, two, three, four, five;
function loadSounds()
{
	explode = new Audio("sounds/Explosion.mp3");
	one = new Audio("sounds/1.mp3");
	two = new Audio("sounds/2.mp3");
	three = new Audio("sounds/3.mp3");
	four = new Audio("sounds/4.mp3");
	five = new Audio("sounds/5.mp3");
}

function init()
{
	loadSounds();


	chair_material = Physijs.createMaterial(
		new THREE.MeshLambertMaterial(),
		.6, // medium friction
		.2 // low restitution
	);

	scene = new Physijs.Scene();
	scene.setGravity(new THREE.Vector3( 0, -50, 0 ));
	scene.addEventListener('update', function() {
		scene.simulate(); // simulate on every scene update
	});


	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .2, 1000 );
	camera.position.set( 0, 200, 150);

	// first person
	//camera.lookAt( new THREE.Vector3( 0, 3, 0 ) );
	camera.lookAt(scene.position);

	renderer = new THREE.WebGLRenderer();
	renderer.setClearColor( 0x000000, 1.0 );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.shadowMapEnabled = true;

	// 1. show a plane representing the bottom of the pong table
	createPlayBottom();

	// 2. Create sideboards, which will be parallelapipeds
	createBoundingWalls();

	// 3. Create the paddles
	createPaddles();

	// 4 Create the ball
	createBall();

	// add pointlight
	var pointLight = new THREE.PointLight( 0xFFFFFF, 1, 100 );
	pointLight.position.set( 0, 0, 20);
	//scene.add(pointLight);

	light = new THREE.DirectionalLight( 0xFFFFFF );
	light.position.set( 10, 20, 10 );
	light.target.position.copy( scene.position );
	light.castShadow = true;
	light.shadowCameraLeft = -60;
	light.shadowCameraTop = -60;
	light.shadowCameraRight = 60;
	light.shadowCameraBottom = 60;
	light.shadowCameraNear = 20;
	light.shadowCameraFar = 200;
	light.shadowBias = -.0001
	light.shadowMapWidth = light.shadowMapHeight = 2048;
	light.shadowDarkness = .7;
	scene.add( light );	

	// add score box
	var gui = new dat.GUI();
	gui.add(score, 'score1').listen()
	gui.add(score, 'score2').listen()
	gui.add(score, 'firstPerson')

	scene.simulate();
	//spawnChair();
	

	document.body.appendChild( renderer.domElement );		
	render();

}

function render()
{
	moveBallAndMaintainPaddles();
	paddle1.__dirtyPosition = true;
	paddle2.__dirtyPosition = true;
	requestAnimationFrame( render );
	renderer.render( scene, camera );
}

window.addEventListener( 'resize', onWindowResize, false );

function onWindowResize(){

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}

spawnChair = (function() {
		var buildBack, buildLegs, doSpawn;

		buildBack = function() {
		var back, _object;

		back = new Physijs.BoxMesh(
				new THREE.BoxGeometry( 5, 1, .5 ),
				chair_material
				);
		back.position.y = 5;
		back.position.z = -2.5;
		back.castShadow = true;
		back.receiveShadow = true;

		// rungs - relative to back
		_object = new Physijs.BoxMesh(
				new THREE.BoxGeometry( 1, 5, .5 ),
				chair_material
				);
		_object.position.y = -3;
		_object.position.x = -2;
		_object.castShadow = true;
		_object.receiveShadow = true;
		back.add( _object );

		_object = new Physijs.BoxMesh(
				new THREE.BoxGeometry( 1, 5, .5 ),
				chair_material
				);
		_object.position.y = -3;
		_object.castShadow = true;
		_object.receiveShadow = true;
		back.add( _object );

		_object = new Physijs.BoxMesh(
				new THREE.BoxGeometry( 1, 5, .5 ),
				chair_material
				);
		_object.position.y = -3;
		_object.position.x = 2;
		_object.castShadow = true;
		_object.receiveShadow = true;
		back.add( _object );

		return back;
		};

		buildLegs = function() {
			var leg, _leg;

			// back left
			leg = new Physijs.BoxMesh(
					new THREE.BoxGeometry( .5, 4, .5 ),
					chair_material
					);
			leg.position.x = 2.25;
			leg.position.z = -2.25;
			leg.position.y = -2.5;
			leg.castShadow = true;
			leg.receiveShadow = true;

			// back right - relative to back left leg
			_leg = new Physijs.BoxMesh(
					new THREE.BoxGeometry( .5, 4, .5 ),
					chair_material
					);
			_leg.position.x = -4.5;
			_leg.castShadow = true;
			_leg.receiveShadow = true;
			leg.add( _leg );

			// front left - relative to back left leg
			_leg = new Physijs.BoxMesh(
					new THREE.BoxGeometry( .5, 4, .5 ),
					chair_material
					);
			_leg.position.z = 4.5;
			_leg.castShadow = true;
			_leg.receiveShadow = true;
			leg.add( _leg );

			// front right - relative to back left leg
			_leg = new Physijs.BoxMesh(
					new THREE.BoxGeometry( .5, 4, .5 ),
					chair_material
					);
			_leg.position.x = -4.5;
			_leg.position.z = 4.5;
			_leg.castShadow = true;
			_leg.receiveShadow = true;
			leg.add( _leg );

			return leg;
		};

		doSpawn = function() {
			var chair, back, legs;

			// seat of the chair
			chair = new Physijs.BoxMesh(
					new THREE.BoxGeometry( 5, 1, 5 ),
					chair_material
					, 0.1
					);
			chair.castShadow = true;
			chair.receiveShadow = true;

			// back - relative to chair ( seat )
			back = buildBack();
			chair.add( back );

			// legs - relative to chair ( seat )
			legs = buildLegs();
			chair.add( legs );

			chair.position.y = 40;
			chair.position.x = Math.random() * 50 - 25;
			chair.position.z = Math.random() * 50 - 25;

			chair.rotation.set(
					Math.random() * Math.PI * 2,
					Math.random() * Math.PI * 2,
					Math.random() * Math.PI * 2
					);

			chair.addEventListener( 'ready', spawnChair );
			scene.add( chair );
		};

		var count = 0
		return function() {
			setTimeout( doSpawn, 1000 );
			count++;
			if (count == 30){
				return
			}
		};
})();


window.onload = init;
</script>

</body>

</html>

